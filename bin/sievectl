#!/usr/bin/env ruby
#
#--
# Copyright (c) 2004-2006 Andre Nathan <andre@digirati.com.br>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#++
#
# = Overview
#
# Sievectl is a utility that allows for management of
# Sieve[http://www.cyrusoft.com/sieve/] scripts from the command line. It
# supports multiple accounts, configured in the .sievectlrc file located in
# the user's home directory.
#
# == Configuration file example
#
#  accountA:
#    host:     sieve.accounta.tld
#    port:     2000
#    user:     johndoe
#    euser:    johndoe
#    password: secret
#    auth:     PLAIN
#
#  accountB:
#    host:     mail.accountb.tld
#    user:     john
#    password: secret
#    auth:     PLAIN
#
# The +port+ and +euser+ parameters can be ommited, and will respectively
# default to 2000 and the value of the +user+ parameter. If the +auth+
# parameter is ommited, it will default to +ANONYMOUS+.
#
# == Usage and examples
#
#  $ sievectl help
#  Usage: sievectl <account> <action> [script name]
#  Action is one of:
#    capabilities, list, show, activate, deactivate, add, addactive, delete
#  
#  Short forms for some actions are also accepted:
#    caps (capabilities), act (activate), deact (deactivate),
#    addact (addactive), del (delete)
#  
#    Examples:
#      List server capabilities:
#        sievectl myaccount caps
#  
#      List available scripts:
#        sievectl myaccount list
#  
#      Show contents of a script:
#        sievectl myaccount show scriptname
#  
#      Add a script:
#        sievectl myaccount add scriptname script.txt
#        or
#        sievectl myaccount add scriptname < script.txt
#        or
#        cat script.txt | sievectl myaccount add scriptname
#  
#      Delete a script:
#        sievectl myaccount del scriptname
#
#--
# $Id: sievectl,v 1.26 2006/08/30 17:42:30 andre Exp $
#++
#

begin
  require 'rubygems'
rescue LoadError
end
require 'managesieve'

$has_termios = true
begin
  require_gem 'termios'
rescue LoadError
  begin
    require 'termios'
  rescue LoadError
    $has_termios = false
  end
end

require 'yaml'

class ManageSieve # :nodoc:
  def print_capabilities
    puts 'Capabilities:'
    @capabilities.sort.each { |cap| puts "  - #{cap}" }

    puts 'Login Mechanisms:'
    @login_mechs.sort.each { |mech| puts "  - #{mech}" }
  end

  def print_scripts
    puts 'Available scripts:'
    scripts.sort.each do |name, active|
      print "  - #{name}"
      print active ? " (active)\n" : "\n"
    end
  end

  def upload_script(name, script, active=false)
    put_script(name, script)
    set_active(name)
  end
end

class TemplateError < Exception # :nodoc:
end

class ConfigFile < File # :nodoc:
  def ConfigFile.open(name)
    begin
      conf = nil
      super(name) do |file|
        conf = YAML::load(file)
      end
      conf.each_key do |acct|
        conf[acct].each_key { |k| conf[acct][k] = conf[acct][k].to_s }
      end
      conf
    rescue Errno::ENOENT
      ConfigFile::create_template(name)
      exit 0
    end
  end

  private
  def ConfigFile.create_template(name)
    STDERR.puts <<-__EOF__
* Could not find configuration file #{name}.
* A template file will be created. Please edit the values to fit your
* local configuration and run `#{File::basename $0}' again.
    __EOF__

    begin
      file = File.new(name, 'w', 0600)
      file.puts <<-__EOF__
accountname:
  host:     servername
  port:     port
  user:     username
  euser:    effectiveusername
  password: password
  auth:     authmethod
      __EOF__
    rescue => e
      raise TemplateError, e
    end
  end
end

#
# The SieveCtl class is a simple set of wrapper methods around the ones
# available on the #ManageSieve class.
#
class SieveCtl
  def initialize(conf)
    @manage_sieve = ManageSieve.new(conf)
  end

  # Prints the server capabilities.
  def capabilities
    @manage_sieve.print_capabilities
  end

  # Lists the available scripts, specifying which one is active.
  def list
    @manage_sieve.print_scripts
  end

  # Shows the contents of +script+.
  def show(script)
    raise ArgumentError, "`show' requires a script name" unless script
    puts @manage_sieve.get_script(script)
  end

  # Activates +script+.
  def activate(script)
    raise ArgumentError, "`activate' requires a script name" unless script
    @manage_sieve.set_active(script)
  end

  # Deactivates +script+. There is no +DEACTIVATE+ command in the MANAGESIEVE
  # draft, so we fetch the script, remove it and upload it again.
  def deactivate(script)
    raise ArgumentError, "`deactivate' requires a script name" unless script
    data = @manage_sieve.get_script(script)
    @manage_sieve.delete_script(script)
    @manage_sieve.put_script(script, data)
  end

  # Adds a script named +script+, from file +file+. If +file+ is +nil+, read
  # the script from +STDIN+. Activates the script is +active+ is true.
  def add(script, file=nil, active=false)
    action = "add#{active ? 'active' : ''}"
    raise ArgumentError, "`#{action}' requires a script name" unless script
    data = file ? File.open(file).readlines : STDIN.readlines
    @manage_sieve.put_script(script, data.to_s)
    activate script if active
  end

  # Deletes +script+
  def delete(script)
    raise ArgumentError, "`activate' requires a script name" unless script
    @manage_sieve.delete_script(script)
  end
end

def usage(quit=true, out=STDERR) # :nodoc: #
  prog = File.basename $0
  out.puts <<-__EOF__
Usage: #{prog} <account> <action> [script name]
Action is one of:
  capabilities, list, show, activate, deactivate, add, addactive, delete

You can also try `#{prog} help' for usage examples.
  __EOF__
  exit 1 if quit
end

def help # :nodoc:
  prog = File::basename $0
  usage(false, STDOUT)
  puts <<-__EOF__

Short forms for some actions are also accepted:
  caps (capabilities), act (activate), deact (deactivate), addact (addactive),
  del (delete)

Examples:
  List server capabilities:
    #{prog} myaccount caps

  List available scripts:
    #{prog} myaccount list

  Show contents of a script:
    #{prog} myaccount show scriptname

  Add a script:
    #{prog} myaccount add scriptname script.txt
    or
    #{prog} myaccount add scriptname < script.txt
    or
    cat script.txt | #{prog} myaccount add scriptname

  Delete a script:
    #{prog} myaccount del scriptname
  __EOF__
  exit 0
end


#
# Main
#

help if ARGV[0] =~ /^h(elp)?$/i

account, action, name, file = ARGV
usage if action.nil?

begin
  conf = ConfigFile::open(ENV['HOME'] + '/.sievectlrc')
rescue TemplateError => e
  STDERR.puts "Cannot create template configuration file: #{e}"
  exit 1
rescue => e
  STDERR.puts "Cannot load configuration file: `#{e}'"
  exit 1
end

unless conf.has_key? account
  STDERR.puts <<-__EOF__
* Configuration for account `#{account}' not found.
* Maybe your configuration file is in the old format?
  __EOF__
  exit 1
end

info = conf[account]

if $has_termios and info['password'].nil?
  oldt = Termios.tcgetattr(STDIN)
  newt = oldt.dup
  newt.lflag &= ~Termios::ECHO
  Termios.tcsetattr(STDIN, Termios::TCSANOW, newt)
  print 'Password: '
  info['password'] = STDIN.gets
  Termios.tcsetattr(STDIN, Termios::TCSANOW, oldt)
end

if info['password'].nil?
  STDERR.puts "* Password not given."
  exit 1
end

info['password'].chomp!

begin
  sievectl = SieveCtl.new(
    :host     => info['host'],
    :port     => info['port'] || 2000,
    :user     => info['user'],
    :euser    => info['euser'] || info['user'],
    :password => info['password'],
    :auth     => info['auth']
  )
rescue SieveNetworkError => e
  STDERR.puts "* #{e}"
  exit 1
end

begin
  case action
  when /^act(ivate)?$/
    sievectl.activate(name)
  when /^add$/
    sievectl.add(name, file)
  when /^addact(ive)?/
    sievectl.add(name, file, true)
  when /^cap(abilitie)?s$/
    sievectl.capabilities
  when /^deact(ivate)?$/
    sievectl.deactivate(name)
  when /^del(ete)?$/
    sievectl.delete(name)
  when /^list$/
    sievectl.list
  when /^show$/
    sievectl.show(name)
  else
    usage
  end
rescue SieveCommandError => e
  STDERR.puts "* #{e}"
end
